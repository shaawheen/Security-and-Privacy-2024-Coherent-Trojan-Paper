# Data Leak (Active new devil Ip design)

This attack steals a RSA key generated by openSSL. 

## Description 

The app 1 generates a RSA key par and shares the public key. The public key is
used by an app 2 to encrypt a file (file.enc) and it's sent back to app 1.
The malicious app 3 steals the RSA key and intercepts the file.enc (transmitted
through an unsecure channel) and decrypts file.enc with the stolen private KEY, 
accessing the secrets.

To do this attack we rely on the fact that each file have a specific header and 
footer ([see](https://en.wikipedia.org/wiki/List_of_file_signatures)). We use 
the header of the .pem ([see](https://mbed-tls.readthedocs.io/en/latest/kb/cryptography/asn1-key-structures-in-der-and-pem/)). as a magical pattern to find when the app 
1 or app 2 uses a private key.


Artifacts of this attack:
- `find_pattern` -> Configures the coherent Trojan and triggers the malicious IP
- `openssl.sh` -> Two functions: (1) Emulating App 1 & 2, by generating a RSA 
key par and Encrypting a file; (2) Emulates App 3 and decrypts file.enc with the
stolen private key from App 1;  
- `read_BRAM` -> read the the coherent trojan IP BRAM, where the stolen RSA key 
is stored and creates a file (stolen_private_key.pem) with the private key.
- `rsa_attack.sh` -> Runs all the attack automatically
  
## Setup
- Commit: [1e3c93020584deb69eeadcd685f7373207d453a4](https://github.com/ESCristiano/devil-in-the-fpga/tree/1e3c93020584deb69eeadcd685f7373207d453a4)
- Attack Scenario: Attack Cross-Process ( But working in all 3 scenarios)
- Board: zcu104
- OpenSSL version : 3.3.0-dev 

## Build OpenSSL
- We provide the the OpenSSL binaries already cross-compiled, but if you want to
compile yourself (maybe for other linux or OpenSSL version) you can do that by
following OpenSSL cross-compilation guide ([see](https://github.com/openssl/openssl/blob/master/INSTALL.md#cross-compile-prefix)).
  
## To Replicate (Manually)
1. Switch to setup commit
2. `cd software  `
	- Issue a `nix-build` command
	- Plug the SD_card
	- Run `./result-9`
	- Power up the system, stop the u-boot and insert the command:
	    - `fatload mmc 0 0x200000 bao.img; bootm start 0x200000; bootm loados; bootm go`
3. `cd software/artifacts/linux-apps`
	- `./find_pattern`
		- Run `2_send.sh`
	- `./openssl.sh`
		- Run `2_send.sh`
    - `./read_BRAM`
		- Run `2_send.sh`
4. Run on the board's Linux:
   1. `find_pattern`;
   2. `openssl.sh enc`;
   3. `read_BRAM -cmd char`; 
   4.  `openssl.sh dec`.
5. You should have 6 new files: 
   1. `file.txt` -> Plaintext;
   2. `file.enc` -> Cyphertext, generated by `openssl.sh enc`;
   3. `private.pem` -> RSA private key, generated by `openssl.sh enc`;
   4. `public.pem` -> RSA public key, generated by `openssl.sh enc`;
   5. `stolen_private_key.pem` -> Stolen RSA private key, generated by `read_BRAM -cmd char`;
   6. `file.dec` -> Original Plaintext Decrypted with stolen RSA private key, generated by `openssl.sh dec`;

## To Replicate (Automatically)
1. Switch to this READM Commit
2. Run `send.sh` on host linux
3. Run `rsa_attack.sh` on boards's linux
4. You should have 6 new files: 
   1. `file.txt` -> Plaintext;
   2. `file.enc` -> Cyphertex, generated by `openssl.sh enc`;
   3. `private.pem` -> RSA private key, generated by `openssl.sh enc`;
   4. `public.pem` -> RSA public key, generated by `openssl.sh enc`;
   5. `stolen_private_key.pem` -> Stolen RSA private key, generated by `read_BRAM -cmd char`;
   6. `file.dec` -> Original Plaintex Decrypetd with stolen RSA private key, generated by `openssl.sh dec`;

## To Replicate "Meta-Evaluation"

If you want to run several times the experiments to get the rate of success, you can do so by run the following scripts:
- `run_eval.sh send` -> [**Host**] To send the scripts to the target board
- `eval.sh` -> [**Board**] Run the following scripts
- `run_eval.sh results` -> [**Host**] To get the results and the success rate

## Results 
- We can read arbitrary memory (EL1, EL2, EL3) breaking Confidentiality